import json
from typing import Any
from django.core.mail import send_mail
from django.http import HttpResponse
from django.views.decorators.csrf import csrf_exempt
from django.shortcuts import render
from django.conf import settings
from django.views import View
from django.views.generic import TemplateView
import stripe
from django.http import JsonResponse
from .models import Product

# Create your views here .
# Payment method online .
# Accept Online Payments .
stripe.api_key = settings.STRIPE_SECRET_KEY


class CancelView(TemplateView):
    template_name = "cancel.html"


class SuccessView(TemplateView):
    template_name = "success.html"


class ProductLandingPageView(TemplateView):
    template_name = "landing.html"

    def get_context_data(self, **kwargs):
        product = Product.objects.get(name="Test 2")
        context = super(ProductLandingPageView, self).get_context_data(**kwargs)
        context.update({
            "product":product,
            "STRIPE_PUBLIC_KEY": settings.STRIPE_PUBLIC_KEY
        })
        return context


class CreateCheckoutSessionView(View):
    def post(self, request, *args, **kwargs):
        # print(**kwargs)
        product_id = self.kwargs["pk"]
        # print(product_id)
        # print(kwargs)  # {'pk':2}
        product = Product.objects.get(id=product_id)
        # print(product)
        YOUR_DOMAIN = "http://127.0.0.1:8000/"
        checkout_session = stripe.checkout.Session.create(
            line_items=[
                {
                    # Provide the exact Price ID (for example, pr_1234) of the product you want to sell
                    # 'price': '{{PRICE_ID}}',
                    'price_data':{
                        'currency':'usd',
                        'unit_amount':product.price,
                        'product_data':{
                            'name':product.name
                        },
                    },
                    'quantity': 1, # as for the single item the its price taken would be one , it should display like if a product price is 100 then then the qty is saying it's one and make the price to be paid of 100 
                },
            ],
            metadata = {
                "product_id":product.id                                                                                     
            },


            # we will grap the email from the customer_details (it comes from the session when event gets completed at webhooks)
            # but it won't have much info about which product is purchased so we will use meta as it to pass in some specific info (in the customer section of session)

            mode='payment',
            success_url=YOUR_DOMAIN + '/success/',
            cancel_url=YOUR_DOMAIN + '/cancel/',
        )

        return JsonResponse({
            "id":checkout_session.id
        })
    


# We can't be truely sure about the successful payment if we got the success page. So, for us to be sure stripe has a concept of webhooks
# So webhook is an event that is sent to us by stripe and this incdicates that something has happened # SO in the context for here stripe will sent us this event when the payment was successful
# payload is the data we want to send through API
# In the provided code, the session refers to the information associated with a Stripe Checkout session.When a customer initiates a payment through Stripe Checkout, a session is created to manage the payment process. This session contains various details about the transaction, such as the customer's information, payment status, and any relevant metadata.



# Verification Of the Events
@csrf_exempt  # we use csrf exempt to make the view not require a csrf token
def stripe_webhook(request):
    payload = request.body # it will contain most of the info about the wehbook
    sig_header = request.META['HTTP_STRIPE_SIGNATURE']    # its a header in a request # This header typically contains the signature generated by Stripe to authenticate the webhook event.
    event = None

    try:
        event = stripe.Webhook.construct_event(
        payload, sig_header, settings.STRIPE_WEBHOOK_SECRET     #  This is a piece of information attached to the webhook request. It's like a seal that Stripe puts on the envelope to prove it's from them. This seal is called a signature, and it ensures the data hasn't been altered during transit. 
        )
        print(f"Sig header : {sig_header}")
        if not sig_header:
            return HttpResponse(status=400, content="Stripe signature header missing")
    except ValueError as e:
        # Invalid payload
        return HttpResponse(status=400)
    except stripe.error.SignatureVerificationError as e:
        # Invalid signature
        return HttpResponse(status=400)
    

    if event['type'] == 'checkout.session.completed':
        print(event)
        print(event["type"])
        # Retrieve the session. If you require line items in the response, you may include them by expanding line_items.
        session = stripe.checkout.Session.retrieve(
        event['data']['object']['id'],
        expand=['line_items'],
        )
        print(session)

        # # Now since we have passed the meta data for our desired info in the above create checkout session view.

        customer_email= session["customer_details"]["email"]           # as it is already defined in the response of session from customer details so we'll directly fetch it here
        product_id = session["metadata"]["product_id"]                  # Product id is sent by us at the create-checkout-session.

        product = Product.objects.get(id=product_id)

        # Now since we have the user email we can send him/her mail using:
        send_mail(
            subject="Here is your product",
            message="Thanks for your purchase",
            recipient_list=[customer_email],
            from_email="abdulrafayatiq.03@gmail.com"
        )

        # line_items = session.line_items
        # # Fulfill the purchase...
        # fulfill_order(line_items)

    # Passed signature verification
    return HttpResponse(status=200)

# def fulfill_order(line_items):
#     print("Fulfilling order")
    



# Payment Intent : A PaymentIntent guides you through the process of collecting a payment from your customer .
# It creates a PaymentIntent Object .
# Now when the below api hits , then we will get the payment_intent.succeeded -- as we created payment intent view we'll check that in webhook as created our cus
class StripeIntentView(View):
    def post(self, request ,*args, **kwargs):
        try:
            requested_json = json.loads(request.body)
            print(requested_json["email"])
            customer = stripe.Customer.create(
                email=requested_json["email"]
            )

            product_id = self.kwargs["pk"]
            product = Product.objects.get(id=product_id)
            # Create a PaymentIntent with the order amount and currency
            intent = stripe.PaymentIntent.create(
                amount=product.price,
                currency='usd',
                customer=customer["id"],
                # In the latest version of the API, specifying the `automatic_payment_methods` parameter is optional because Stripe enables its functionality by default.
                automatic_payment_methods={
                    'enabled': True,
                },
            )
            return JsonResponse({
                'clientSecret': intent['client_secret']  # on successful payment , it will return the client-secret from intent 
            })
        except Exception as e:
            return JsonResponse(error=str(e)), 403
        



